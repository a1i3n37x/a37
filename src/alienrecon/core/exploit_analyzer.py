# src/alienrecon/core/exploit_analyzer.py
"""Exploit analysis and suggestion system."""

import logging
import re
from typing import Any

from .tool_orchestrator import ToolOrchestrator

logger = logging.getLogger(__name__)


class ExploitAnalyzer:
    """Analyzes reconnaissance results and suggests potential exploits."""

    # Known vulnerable service patterns
    VULNERABLE_SERVICES = {
        "vsftpd": {
            "2.3.4": {
                "cve": "CVE-2011-2523",
                "description": "VSFTPD 2.3.4 Backdoor Command Execution",
                "metasploit": "exploit/unix/ftp/vsftpd_234_backdoor",
                "risk": "critical"
            }
        },
        "samba": {
            "3.0.20": {
                "cve": "CVE-2007-2447",
                "description": "Samba 'username map script' Command Execution",
                "metasploit": "exploit/multi/samba/usermap_script",
                "risk": "critical"
            }
        },
        "distccd": {
            "1": {  # Any version
                "cve": "CVE-2004-2687",
                "description": "DistCC Daemon Command Execution",
                "metasploit": "exploit/unix/misc/distcc_exec",
                "risk": "high"
            }
        },
        "apache": {
            "2.2": {
                "description": "Various Apache 2.2.x vulnerabilities",
                "search_terms": ["apache 2.2", "mod_ssl", "mod_rewrite"],
                "risk": "medium"
            }
        },
        "ssh": {
            "libssh": {
                "cve": "CVE-2018-10933",
                "description": "libSSH Authentication Bypass",
                "search_terms": ["libssh authentication bypass"],
                "risk": "high"
            }
        }
    }

    def __init__(self, tool_orchestrator: ToolOrchestrator):
        self.tool_orchestrator = tool_orchestrator

    def analyze_session_results(self, session_state: dict[str, Any]) -> dict[str, Any]:
        """Analyze session results and generate exploit suggestions."""
        suggestions = {
            "vulnerable_services": [],
            "exploit_searches": [],
            "manual_research": [],
            "next_steps": []
        }

        # Analyze open ports and services
        open_ports = session_state.get("open_ports", [])
        for port_info in open_ports:
            service_suggestions = self._analyze_service(port_info)
            if service_suggestions:
                suggestions["vulnerable_services"].extend(service_suggestions)

        # Analyze web findings for vulnerabilities
        web_findings = session_state.get("web_findings", {})
        for url, findings in web_findings.items():
            web_suggestions = self._analyze_web_findings(url, findings)
            if web_suggestions:
                suggestions["exploit_searches"].extend(web_suggestions)

        # Generate search terms for discovered services
        search_terms = self._generate_search_terms(open_ports)
        suggestions["exploit_searches"].extend(search_terms)

        # Generate manual research suggestions
        suggestions["manual_research"] = self._generate_manual_research(open_ports)

        # Generate next steps
        suggestions["next_steps"] = self._generate_next_steps(suggestions)

        return suggestions

    def _analyze_service(self, port_info: dict[str, Any]) -> list[dict[str, Any]]:
        """Analyze a single service for known vulnerabilities."""
        suggestions = []
        service = port_info.get("service", "").lower()
        version = port_info.get("version", "").lower()
        port = port_info.get("port")

        # Check against known vulnerable services
        for service_name, versions in self.VULNERABLE_SERVICES.items():
            if service_name in service:
                # Check specific versions
                for version_pattern, vuln_info in versions.items():
                    if version_pattern in version or version_pattern == "1":  # "1" means any version
                        suggestion = {
                            "service": f"{service} ({port}/tcp)",
                            "vulnerability": vuln_info.get("description", "Unknown vulnerability"),
                            "cve": vuln_info.get("cve"),
                            "metasploit_module": vuln_info.get("metasploit"),
                            "risk_level": vuln_info.get("risk", "medium"),
                            "search_terms": vuln_info.get("search_terms", [service_name, version_pattern]),
                            "port": port
                        }
                        suggestions.append(suggestion)

        # Generate generic suggestions for unmatched services
        if not suggestions and service and service != "unknown":
            suggestion = {
                "service": f"{service} ({port}/tcp)",
                "vulnerability": f"Potential vulnerabilities in {service}",
                "search_terms": [service, version] if version else [service],
                "risk_level": "low",
                "port": port
            }
            suggestions.append(suggestion)

        return suggestions

    def _analyze_web_findings(self, url: str, findings: dict[str, Any]) -> list[dict[str, Any]]:
        """Analyze web findings for exploit opportunities."""
        suggestions = []

        # Check for vulnerabilities from Nikto
        vulnerabilities = findings.get("vulnerabilities", [])
        for vuln in vulnerabilities:
            if isinstance(vuln, str):
                # Extract potential CVEs or vulnerability indicators
                cve_match = re.search(r'CVE-\d{4}-\d{4,}', vuln)
                if cve_match:
                    suggestions.append({
                        "type": "web_vulnerability",
                        "url": url,
                        "description": vuln,
                        "cve": cve_match.group(0),
                        "search_terms": [cve_match.group(0)]
                    })
                elif any(keyword in vuln.lower() for keyword in ["sql", "xss", "rfi", "lfi", "upload"]):
                    suggestions.append({
                        "type": "web_vulnerability",
                        "url": url,
                        "description": vuln,
                        "search_terms": [vuln.split()[0] if vuln.split() else "web"]
                    })

        # Check for interesting directories that might indicate vulnerable applications
        directories = findings.get("directories", [])
        for directory in directories:
            if any(app in directory.lower() for app in ["admin", "phpmyadmin", "wp-admin", "backup"]):
                suggestions.append({
                    "type": "web_application",
                    "url": f"{url}/{directory}",
                    "description": f"Potentially interesting directory: {directory}",
                    "search_terms": [directory.replace("/", "")]
                })

        return suggestions

    def _generate_search_terms(self, open_ports: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Generate searchsploit search terms based on discovered services."""
        search_terms = []

        for port_info in open_ports:
            service = port_info.get("service", "")
            version = port_info.get("version", "")

            if service and service != "unknown":
                # Create search term combinations
                terms = []

                # Service name only
                terms.append(service)

                # Service + version if available
                if version:
                    # Clean up version string
                    clean_version = re.sub(r'[^\d\.]', '', version.split()[0] if version.split() else version)
                    if clean_version:
                        terms.append(f"{service} {clean_version}")

                # Service + major version only
                if version:
                    major_version = re.search(r'\d+\.\d+', version)
                    if major_version:
                        terms.append(f"{service} {major_version.group(0)}")

                for term in terms:
                    search_terms.append({
                        "query": term,
                        "service": service,
                        "port": port_info.get("port"),
                        "type": "service_search"
                    })

        return search_terms

    def _generate_manual_research(self, open_ports: list[dict[str, Any]]) -> list[str]:
        """Generate manual research suggestions."""
        suggestions = []

        for port_info in open_ports:
            service = port_info.get("service", "")
            version = port_info.get("version", "")
            port = port_info.get("port")

            if service and service != "unknown":
                if version:
                    suggestions.append(
                        f"Research {service} {version} vulnerabilities using: "
                        f"`searchsploit {service} {version}`"
                    )
                    suggestions.append(
                        f"Check Metasploit modules: "
                        f"`search {service}` in msfconsole"
                    )
                else:
                    suggestions.append(
                        f"Research {service} vulnerabilities on port {port}: "
                        f"`searchsploit {service}`"
                    )

        # Add general research suggestions
        if open_ports:
            suggestions.extend([
                "Check for default credentials on discovered services",
                "Look for version-specific CVEs on CVE MITRE database",
                "Research service-specific exploitation techniques",
                "Consider privilege escalation paths after gaining initial access"
            ])

        return suggestions

    def _generate_next_steps(self, suggestions: dict[str, Any]) -> list[str]:
        """Generate prioritized next steps based on analysis."""
        next_steps = []

        # High priority items first
        vulnerable_services = suggestions.get("vulnerable_services", [])
        critical_vulns = [v for v in vulnerable_services if v.get("risk_level") == "critical"]

        if critical_vulns:
            next_steps.append("🚨 CRITICAL: Focus on critical vulnerabilities first")
            for vuln in critical_vulns:
                if vuln.get("metasploit_module"):
                    next_steps.append(
                        f"Try Metasploit module: `use {vuln['metasploit_module']}`"
                    )

        # Medium priority searches
        exploit_searches = suggestions.get("exploit_searches", [])
        if exploit_searches:
            next_steps.append("🔍 Run exploit database searches for discovered services")
            # Limit to top 3 most relevant searches
            for search in exploit_searches[:3]:
                next_steps.append(f"Search: `searchsploit {search.get('query', '')}`")

        # Manual research
        if not critical_vulns:
            next_steps.append("📚 Conduct manual research on discovered services")
            manual_research = suggestions.get("manual_research", [])
            if manual_research:
                next_steps.extend(manual_research[:2])  # Top 2 research suggestions

        return next_steps

    async def search_exploits(self, query: str, **kwargs) -> dict[str, Any]:
        """Search for exploits using searchsploit."""
        try:
            result = await self.tool_orchestrator.execute_tool_async(
                "searchsploit",
                {"query": query, **kwargs}
            )
            return result
        except Exception as e:
            logger.error(f"Error searching exploits: {e}")
            return {
                "success": False,
                "error": str(e),
                "findings": []
            }

